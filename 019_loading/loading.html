<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>d3.js</title>
    <script src="../common/js/d3.v4.min.js"></script>
    <script src="./tooltip.js"></script>
    <link rel="stylesheet" href="../common.css" />
</head>
<style>
</style>
<body>
<h3>D3 Data Loading</h3>

<div id="output">
</div>

<script>

function getRandomIntInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min; //The maximum is inclusive and the minimum is inclusive
}

function getRandomData(numberOfData, min, max){
    var result = [], i;
    for (i=1; i<=numberOfData; i++){
        result.push({key: new Date("2017-01-"+i), value: getRandomIntInclusive(min, max)});
    }
    return result;
}

var data = [
    { key: 1, value: 4},
    { key: 2, value: 5},
    { key: 3, value: 6},
    { key: 4, value: 3},
    { key: 5, value: 2},
    { key: 6, value: 7},
    { key: 7, value: 5},
    { key: 8, value: 6},
    { key: 9, value: 7},
    { key: 10, value: 3}
];

var dataUpdated = [
    { key: 1, value: 4},
    { key: 2, value: 6},
    { key: 3, value: 3},
    { key: 4, value: 2},
    { key: 5, value: 5},
    { key: 6, value: 1},
    { key: 7, value: 2},
    { key: 8, value: 5},
    { key: 9, value: 3},
    { key: 10, value: 2}
];

function createChart(data, fieldX, fieldY){

    var w = 500;
    var h = 250;

    var svg = d3.select("#output")
            .append("svg")
            .attr("width", w)
            .attr("height", h)
            .style("background-color", "#eeeeee");

    var padding = 50;

    var valueFormat = d3.format(",.1f");
    var keyFormat = d3.timeFormat("%b-%y");

    var xMin = d3.min(data, function(d){ return d[fieldX]; });
    var xMax = d3.max(data, function(d){ return d[fieldX]; });
    var xWidth = (w - 2 * padding) / data.length;
    var xScale = d3.scaleTime()
            .domain([xMin, xMax])
            .range([padding, w - xWidth - padding]);

    console.log("xMin", xMin);
    console.log("xMax", xMax);

    var yMin = d3.min(data, function(d){ return d[fieldY]; }) * 0.9;
    var yMax = d3.max(data, function(d){ return d[fieldY]; });
    var yScale = d3.scaleLinear()
            .domain([yMin, yMax])
            .range([h-padding, padding]);
    var heightScale = d3.scaleLinear()
            .domain([yMin, yMax])
            .range([0, h - 2*padding]);

    var chartBackLayer = svg.append("g");
    var chartLayer = svg.append("g");
    var tooltipLayer = svg.append("g");

    var tooltip = createTooltip(tooltipLayer);

    var lineFn = d3.line()
            .x(function(d){ return xScale(d[fieldX]); })
            .y(function(d){ return yScale(d[fieldY]); });

    var line = chartLayer
            .append("path")
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 3)
            .attr("d", lineFn([]));
    updateChart(data);

    var xAxisGen = d3
            .axisBottom().scale(xScale)
            .tickFormat(keyFormat);

    var yAxisGen = d3
            .axisLeft().scale(yScale).ticks(5);

    var yAxis = svg.append("g").call(yAxisGen)
            .attr("class", "y axis")
            .attr("transform", "translate(" + (xScale(xMin) - xWidth/2) + ", 0)");

    var xAxis = svg.append("g").call(xAxisGen)
            .attr("class","x axis")
            .attr("transform", "translate(0," + yScale(yMin) + ")");

    function updateChart(data){

        var xMin = d3.min(data, function(d){ return d[fieldX]; });
        var xMax = d3.max(data, function(d){ return d[fieldX]; });
        var xWidth = (w - 2 * padding) / data.length;
        xScale
                .domain([xMin, xMax])
                .range([padding, w - xWidth - padding]);

        var yMin = d3.min(data, function(d){ return d[fieldY]; }) * 0.9;
        var yMax = d3.max(data, function(d){ return d[fieldY]; });
        yScale
                .domain([yMin, yMax])
                .range([h-padding, padding]);
        heightScale
                .domain([yMin, yMax])
                .range([0, h - 2*padding]);

        var xAxisGen = d3
                .axisBottom().scale(xScale).ticks(10);

        var yAxisGen = d3
                .axisLeft().scale(yScale).ticks(5);


        var t = d3.transition()
                .duration(750)
                .ease(d3.easeElastic);

        d3.selectAll(".y.axis")
                .call(yAxisGen)
                .transition(t)
//                .attr("transform", "translate(" + (xScale(xMin) - xWidth/2) + ", 0)");

        d3.selectAll(".x.axis").call(xAxisGen)
                .attr("transform", "translate(0," + yScale(yMin) + ")");

        line
                .transition(t)
                .attr("d", lineFn(data));

        var updateRect = chartBackLayer.selectAll("rect")
                .data(data);

        var newRect = updateRect
                .enter()
                .append("rect")
                .attr("x", function(d){ return xScale(d[fieldX]) - xWidth/2 ; })
                .attr("y", yScale(yMin))
                .attr("width", xWidth)
                .attr("height", 0)
                .attr("fill", "#eeeeee")
                .on("mouseover", function(d) {
                    tooltip.show(valueFormat(d[fieldY]), xScale(d[fieldX]), yScale(d[fieldY]))
                })
                .on("mouseout", function(d) {
                    tooltip.hide();
                });

        newRect.merge(updateRect)
                .attr("y", function(d){ return yScale(d[fieldY]); })
                .attr("height", function(d){ return heightScale(d[fieldY]) })
                .attr("x", function(d){ return xScale(d[fieldX]) - xWidth/2 ; })
                .attr("width", xWidth);

        updateRect
                .exit()
                .remove();
    }

    return {
        update: updateChart

    };

}

//var chart = createChart(getRandomData(10, 2, 13), "key", "value");

//setInterval(function () {
//    var numberOfData = getRandomIntInclusive(8, 12);
//    var randomData = getRandomData(numberOfData, 2, 13);
////    console.log("trigger data update", randomData);
//    chart.update(randomData);
//}, 1000);

d3.csv("../AAPL.csv", function(err, data) {
    console.log(data);
    data = data.map(function(d){ d.DateParsed = new Date(d.Date); return d; });
    console.log(data);
    var chart = createChart(data, "DateParsed", "Adj Close")

})


</script>


</body>
</html>